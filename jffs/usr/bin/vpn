#!/bin/sh

########################################################################
#                                                                      #
#   VPN connector script v4.02                                         #
#   (c) by Tobse (cthullu@protonmail.com) in 2017                      #
#                                                                      #
#   This script must be located on a USB stick, mounted on /jffs and   #
#   expects the presence of the speed check script in /jffs/usr/bin/.  #
#   All scripts must be "chmod ugo+x" in order to be executable.       #
#   The script also expects the presence of the prepared VPN           #
#   configuration files, sorted into directories at the defined        #
#   config files directory, containing the files ca.crt,               #
#   openvpn.conf and ta.key. See the files with these names at         #
#   /tmp/openvpncl for the syntax.                                     #
#                                                                      #
########################################################################

# load config
DIRNAME="$( cd "$( dirname "$0" )" && pwd )"
source $DIRNAME/config
if [ ! -f "$JFFSPATH/myconfig" ]; then
  source $DIRNAME/myconfig
fi

# log script call
if [ "$LOGGING" == "yes" ]; then
  NOWSTAMP=`date "+%Y-%m-%d %H:%M:%S"`
  echo $NOWSTAMP vpn script called >> $GENERALLOG
fi

# check if another instance of the vpn script is running already
NOWSTAMP=`date "+%s"`
if [ -f $VPNLOCKFILE ]; then
  LASTACTIVE=`cat $VPNLOCKFILE`
  RUNNINGSINCE=`expr $NOWSTAMP - $LASTACTIVE`
  if [ $RUNNINGSINCE -gt $MAXVPNEXECTIME ]; then
    rm $VPNLOCKFILE
  else
    echo -e "\033[1;31mAnother instance of the vpn script is running since $RUNNINGSINCE seconds.\033[0m"
    MUSTWAIT=`expr $MAXVPNEXECTIME - $RUNNINGSINCE`
    echo "You can restart this script in $MUSTWAIT seconds."
    exit
  fi
fi
echo $NOWSTAMP >> $VPNLOCKFILE

# check if system supports curl command
CURLSUPPORTED=yes
RESULT=`command -v curl`
if [ "$RESULT" == "" ]; then
  CURLSUPPORTED=no
fi

# kill all speedcheck scripts
killall -q speedcheck

# get command line parameter
PARAM1="$1"

# check for empty parameter 1
if [ "$PARAM1" == "" ]; then
  echo -e "\033[1;31mNo parameter given.\033[0m"
  echo Please use a server directory as parameter from the following list:
  ls $CONFIGFILESDIR
  echo If you\'re not sure which one to pick, just use "rnd" to pick a random server
  exit 1
fi

# check for wrong parameter 1
if [ "$PARAM1" != "rnd" ]; then
  if [ ! -d "$CONFIGFILESDIR/$PARAM1/" ]; then
    echo -e "\033[1;31mDirectory $CONFIGFILESDIR/$PARAM1/ doesn't exist.\033[0m"
    exit 1
  fi
fi

# read servers list outside of loop
if [ "$1" == "rnd" ]; then
  echo Reading servers list...
  SERVERDIRS=`find $CONFIGFILESDIR/ -type d`
  NRDIRS=`ls $CONFIGFILESDIR | wc -l`
  echo Got $NRDIRS servers to connect to.
fi

RETRIESDONE=0
while [[ $RETRIESDONE -lt $MAXTRIES ]]; do

  # if parameter 1 is "rnd" user wants a random server
  # read server configuration directories
  if [ "$1" == "rnd" ]; then

    # count amount of directories
    AMT=0
    for SERVERDIR in $SERVERDIRS ; do
      if [ "$SERVERDIR" != "$CONFIGFILESDIR/" ]; then
        let AMT=$AMT+1
      fi
    done

    # loop as long as server is in excluded list
    EXCLUDECOUNTRIES=$(echo $IGNORECOUNTRIES | tr "," "\n")
    while : ; do

      # generate random number
      # between 1 and amount of server directories
      RND=`awk -v min=1 -v max=$AMT 'BEGIN{srand(); print int(min+rand()*(max-min+1))}'`

      # now pick $RND from list
      CNT=0
      for SERVERDIR in $SERVERDIRS ; do
        if [ "$SERVERDIR" != "$CONFIGFILESDIR/" ]; then
          let CNT=$CNT+1
        fi
        if [ $CNT -eq $RND ]; then
          SERVER=`echo $SERVERDIR | sed "s|$CONFIGFILESDIR/||g"`
          PARAM1=$SERVER
        fi
      done

      # check if selected server is in a to be excluded country
      WRONGCOUNTRY=no
      for i in $EXCLUDECOUNTRIES
      do
        if [ -z "${PARAM1##*$i*}" ]; then
          WRONGCOUNTRY=yes
          break
        fi
      done

      [[ "$WRONGCOUNTRY" == "yes" ]] || break
    done
  fi

  # init
  let TRYNUMBER=$RETRIESDONE+1
  echo
  echo -e "\033[1;37mThis is try #$TRYNUMBER of $MAXTRIES."
  echo -e "Connecting to server $PARAM1.\033[0m"
  OLDIP=`wget -t 3 -T 10 -q -O - $IPADDRESSURL`
  NEWIP=$OLDIP

  # check if we're connected to the VPN
  VPNROUTE=`route -n | grep $VPNINTERFACE`
  if [ "$VPNROUTE" == "" ]; then
    echo -e "\033[1;31mWe're not connected to the VPN.\033[0m"
  else

    # display current public IPv4
    if [ "$OLDIP" == "" ]; then
      echo -e "\033[1;31mCurrent public IPv4 couldn't be determined.\033[0m"
    else
      echo Current public IPv4 is $OLDIP
    fi

    # drop the VPN
    printf "Waiting for the VPN to drop."
    CNT=0
    while [ $CNT -le $DROPTIMEOUT ] && [ "$NEWIP" == "$OLDIP" ]
    do
      killall -q openvpn
      sleep 1
      let CNT=$CNT+1
      printf "."
      NEWIP=$OLDIP
      VPNROUTE=`route -n | grep $VPNINTERFACE`
      if [ "$VPNROUTE" == "" ]; then
        NEWIP=`wget -t 3 -T 10 -q -O - $IPADDRESSURL`
      fi
    done
    echo
  fi

  # display current public IPv4
  if [[ -z "${NEWIP// }" ]]; then
    echo -e "\033[1;31mCurrent public IPv4 couldn't be determined.\033[0m"
  else
    echo Current public IPv4 is $NEWIP
  fi

  # copy given server files and restart the VPN
  cp $CONFIGFILESDIR/$PARAM1/* /tmp/openvpncl/
  chmod og-r /tmp/openvpncl/*
  OPENVPNLOG_OLD=
  LASTLOGLINE=
  if [ -f $VPNLOG ]; then
    LASTLOGLINE=`tail -n1 $VPNLOG`
  fi
  openvpn --config /tmp/openvpncl/openvpn.conf --route-up /tmp/openvpncl/route-up.sh --log $VPNLOG --daemon

  # wait for new IPv4
  OLDIP=$NEWIP
  STARTSTAMP=`date +%s`
  RUNNINGPERIOD=0
  SLEEP=1
  echo "Waiting for the VPN to come up:"
  while [ $RUNNINGPERIOD -le $CONNECTTIMEOUT ] && [ "$NEWIP" == "$OLDIP" ]
  do
    sleep $SLEEP
    OPENVPNLOG_NEW=
    if [ -f $VPNLOG ]; then
      OPENVPNLOG_NEW=`cat $VPNLOG`
      if [ "$OPENVPNLOG_NEW" != "$OPENVPNLOG_OLD" ]; then
        FOUNDLINE="no"
        while read LINE; do
          if [ "$LINE" == "$LASTLOGLINE" ]; then
            FOUNDLINE="yes"
          fi
          if [ "$FOUNDLINE" == "yes" ] && [ "$LINE" != "$LASTLOGLINE" ]; then
            echo -e "\033[1;36m$LINE\033[0m"
          fi
        done < $VPNLOG
        if [ "$FOUNDLINE" == "no" ]; then
          echo -e "\033[1;36m${OPENVPNLOG_NEW}\033[0m"
        fi
      fi
      OPENVPNLOG_OLD=$OPENVPNLOG_NEW
      LASTLOGLINE=`tail -n1 $VPNLOG`
      NEWIP=$OLDIP
      VPNROUTE=`route -n | grep $VPNINTERFACE`
      if [ "$VPNROUTE" != "" ]; then

        # flush DNS and get new public IPv4
        stopservice dnsmasq
        startservice dnsmasq
        NEWIP=`wget -t 3 -T 10 -q -O - $IPADDRESSURL`
      fi
    fi
    NOW=`date +%s`
    RUNNINGPERIOD=`expr $NOW - $STARTSTAMP`
  done

  # echo new IPv4, city and country
  if [ "$NEWIP" == "$OLDIP" ]; then
    echo -e "\033[1;31mIPv4 hasn't changed within $CONNECTTIMEOUT seconds.\033[0m"
    VPNROUTE=`route -n | grep $VPNINTERFACE`
    if [ "$VPNROUTE" == "" ]; then

      # log dead server
      NOWSTAMP=`date "+%Y-%m-%d %H:%M:%S"`
      echo $NOWSTAMP $PARAM1 >> $DEADLOGFILE
      echo -e "\033[1;31mHouston, we have a problem. Connecting to exit node $PARAM1 has failed.\033[0m"
      echo
      echo
    fi
  else
    echo Current server is $PARAM1.
    echo $PARAM1 > $CURRENTSERVERFILE
    
    # display current public IPv4
    if [ "$NEWIP" == "" ]; then
      echo -e "\033[1;31mNew public IPv4 couldn't be determined.\033[0m"
    else
      echo -e "\033[1;32mNew public IPv4 is $NEWIP.\033[0m"
    fi
    
    if [ "$CURLSUPPORTED" == "yes" ]; then
      CITY=$(curl --connect-timeout 3 -ks $IPINFOURL/city)
    else
      CITY=`wget -t 3 -T 10 -q -O - $IPINFOURL/city`
    fi
    if [ "$CITY" == "" ]; then
      CITY="an unknown city"
    fi
    if [ "$CURLSUPPORTED" == "yes" ]; then
      REGION=$(curl --connect-timeout 3 -ks $IPINFOURL/region)
    else
      REGION=`wget -t 3 -T 10 -q -O - $IPINFOURL/region`
    fi
    if [ "$REGION" == "" ]; then
      REGION="an region unknown"
    fi
    if [ "$CURLSUPPORTED" == "yes" ]; then
      ISPN=$(curl --connect-timeout 3 -ks $IPINFOURL/org)
    else
      ISP=`wget -t 3 -T 10 -q -O - $IPINFOURL/org`
    fi
    if [ "$ISP" == "" ]; then
      ISP="an unknown ISP"
    fi
    if [ "$CURLSUPPORTED" == "yes" ]; then
      COUNTRYCODE=$(curl --connect-timeout 3 -ks $IPINFOURL/country)
    else
      COUNTRYCODE=`wget -t 3 -T 10 -q -O - $IPINFOURL/country`
    fi
    if [ "$COUNTRYCODE" == "" ]; then
      COUNTRYCODE="${PARAM1:0:2}"
    fi
    COUNTRYCODE=`echo "$COUNTRYCODE" | awk '{print toupper($0)}'`
    echo $COUNTRYCODE > $CURRENTCOUNTRYFILE
    if [ "$COUNTRYCODE" == "" ]; then
      COUNTRY="country unknown"
    else
      if [ ! -f "$JFFSPATH/$COUNTRIESJSON" ]; then
        wget -q $COUNTRYNAMESJSONURL -P $JFFSPATH -O $COUNTRIESJSON
      fi
      COUNTRY=`cat $JFFSPATH/$COUNTRIESJSON | grep -E -o "\"$COUNTRYCODE\": \"[^\\"]{3,}\"" | grep -E -o '[^\"]{3,}'`
    fi
    echo -e "\033[1;32mNew geolocation is $CITY in $REGION, $COUNTRY."
    echo -e "Our end service provider is $ISP.\033[0m"
    RETRIESDONE=$MAXTRIES
    $SPEEDTESTSCRIPT
    exit
  fi
  let RETRIESDONE=$RETRIESDONE+1
done

echo Rebooting router.
reboot